using System;
using System.Runtime.InteropServices;
using System.Numerics;

namespace BMapSharp.VirtoolsTypes {

    // NOTE: Structures defined in there is only served for marshaling.
    // You should not use them in hash set or anything else,
    // because they do not have proper hash function and compare function.
    // You should use the managed type generated by them instead.

    [StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
    public struct VxVector2 {
        [MarshalAs(UnmanagedType.R4)]
        public float X, Y;

        public VxVector2(float _x = 0.0f, float _y = 0.0f) {
            X = _x; Y = _y;
        }
        public VxVector2(Vector2 vec) {
            FromManaged(vec);
        }

        public void FromManaged(Vector2 vec) {
            X = vec.X; Y = vec.Y;
        }
        public Vector2 ToManaged() {
            return new Vector2(X, Y);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
    public struct VxVector3 {
        [MarshalAs(UnmanagedType.R4)]
        public float X, Y, Z;

        public VxVector3(float _x = 0.0f, float _y = 0.0f, float _z = 0.0f) {
            X = _x; Y = _y; Z = _z;
        }
        public VxVector3(Vector3 vec) {
            FromManaged(vec);
        }

        public void FromManaged(Vector3 vec) {
            X = vec.X; Y = vec.Y; Z = vec.Z;
        }
        public Vector3 ToManaged() {
            return new Vector3(X, Y, Z);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
    public struct VxColor {
        [MarshalAs(UnmanagedType.R4)]
        public float A, R, G, B;

        public VxColor(float _r, float _g, float _b, float _a) {
            A = _a; R = _r; G = _g; B = _b;
            Regulate();
        }
        public VxColor(Vector4 col) {
            FromManagedRGBA(col);
        }
        public VxColor(Vector3 col) {
            FromManagedRGB(col);
        }
        public VxColor(uint val) {
            FromDword(val);
        }

        public void FromManagedRGBA(Vector4 col) {
            R = col.X;  G = col.Y; B = col.Z; A = col.W;
            Regulate();
        }
        public Vector4 ToManagedRGBA() {
            return new Vector4(R, G, B, A);
        }
        public void FromManagedRGB(Vector3 col) {
            R = col.X; G = col.Y; B = col.Z; A = 1.0f;
            Regulate();
        }
        public Vector3 ToManagedRGB() {
            return new Vector3(R, G, B);
        }
        public void FromDword(uint val) {
            B = (val & 0xFFu) / 255.0f;
            val >>= 8;
            G = (val & 0xFFu) / 255.0f;
            val >>= 8;
            R = (val & 0xFFu) / 255.0f;
            val >>= 8;
            A = (val & 0xFFu) / 255.0f;
        }
        public uint ToDword() {
            // regulate self first
            Regulate();
            // build result
            uint val = 0u;
            val |= (uint)(A * 255.0f);
            val <<= 8;
            val |= (uint)(R * 255.0f);
            val <<= 8;
            val |= (uint)(G * 255.0f);
            val <<= 8;
            val |= (uint)(B * 255.0f);
            return val;
        }
        
        public static float ClampFactor(float factor) {
            return System.Math.Clamp(factor, 0.0f, 1.0f);
        }
        public void Regulate() {
            A = ClampFactor(A);
            R = ClampFactor(R);
            G = ClampFactor(G);
            B = ClampFactor(B);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
    public struct VxMatrix {
        [MarshalAs(UnmanagedType.R4)]
        public float M11, M12, M13, M14;
        [MarshalAs(UnmanagedType.R4)]
        public float M21, M22, M23, M24;
        [MarshalAs(UnmanagedType.R4)]
        public float M31, M32, M33, M34;
        [MarshalAs(UnmanagedType.R4)]
        public float M41, M42, M43, M44;

        public VxMatrix(float m11 = 1.0f, float m12 = 0.0f, float m13 = 0.0f, float m14 = 0.0f,
                        float m21 = 0.0f, float m22 = 1.0f, float m23 = 0.0f, float m24 = 0.0f,
                        float m31 = 0.0f, float m32 = 0.0f, float m33 = 1.0f, float m34 = 0.0f,
                        float m41 = 0.0f, float m42 = 0.0f, float m43 = 0.0f, float m44 = 1.0f) {
            M11 = m11; M12 = m12; M13 = m13; M14 = m14;
            M21 = m21; M22 = m22; M23 = m23; M24 = m24;
            M31 = m31; M32 = m32; M33 = m33; M34 = m34;
            M41 = m41; M42 = m42; M43 = m43; M44 = m44;
        }
        public void Reset() {
            M11 = 1.0f; M12 = 0.0f; M13 = 0.0f; M14 = 0.0f;
            M21 = 0.0f; M22 = 1.0f; M23 = 0.0f; M24 = 0.0f;
            M31 = 0.0f; M32 = 0.0f; M33 = 1.0f; M34 = 0.0f;
            M41 = 0.0f; M42 = 0.0f; M43 = 0.0f; M44 = 1.0f;
        }
        public void FromManaged(Matrix4x4 mat) {
            M11 = mat.M11; M12 = mat.M12; M13 = mat.M13; M14 = mat.M14;
            M21 = mat.M21; M22 = mat.M22; M23 = mat.M23; M24 = mat.M24;
            M31 = mat.M31; M32 = mat.M32; M33 = mat.M33; M34 = mat.M34;
            M41 = mat.M41; M42 = mat.M42; M43 = mat.M43; M44 = mat.M44;
        }
        public Matrix4x4 ToManaged() {
            return new Matrix4x4(
                M11, M12, M13, M14,
                M21, M22, M23, M24,
                M31, M32, M33, M34,
                M41, M42, M43, M44
            );
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
    public struct CKFaceIndices {
        [MarshalAs(UnmanagedType.U4)]
        public uint I1, I2, I3;

        public CKFaceIndices(uint i1 = 0u, uint i2 = 0u, uint i3 = 0u) {
            I1 = i1;
            I2 = i2;
            I3 = i3;
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
    public struct CKShortFaceIndices {
        [MarshalAs(UnmanagedType.U2)]
        public ushort I1, I2, I3;

        public CKShortFaceIndices(ushort i1 = 0, ushort i2 = 0, ushort i3 = 0) {
            I1 = i1;
            I2 = i2;
            I3 = i3;
        }
    }

    public enum CK_TEXTURE_SAVEOPTIONS : uint {
        CKTEXTURE_RAWDATA = 0,	/**< Save raw data inside file. The bitmap is saved in a raw 32 bit per pixel format.  */
        CKTEXTURE_EXTERNAL = 1,	/**< Store only the file name for the texture. The bitmap file must be present in the bitmap paths when loading the composition.  */
        CKTEXTURE_IMAGEFORMAT = 2,	/**< Save using format specified. The bitmap data will be converted to the specified format by the correspondant bitmap plugin and saved inside file.  */
        CKTEXTURE_USEGLOBAL = 3,	/**< Use Global settings, that is the settings given with CKContext::SetGlobalImagesSaveOptions. (Not valid when using CKContext::SetImagesSaveOptions).  */
        CKTEXTURE_INCLUDEORIGINALFILE = 4,	/**< Insert original image file inside CMO file. The bitmap file that was used originally for the texture or sprite will be append to the composition file and extracted when the file is loaded.  */
    }

    public enum VX_PIXELFORMAT : uint {
        UNKNOWN_PF = 0, /**< Unknown pixel format  */
        _32_ARGB8888 = 1,   /**< 32-bit ARGB pixel format with alpha  */
        _32_RGB888 = 2, /**< 32-bit RGB pixel format without alpha  */
        _24_RGB888 = 3, /**< 24-bit RGB pixel format  */
        _16_RGB565 = 4, /**< 16-bit RGB pixel format  */
        _16_RGB555 = 5, /**< 16-bit RGB pixel format (5 bits per color)  */
        _16_ARGB1555 = 6,   /**< 16-bit ARGB pixel format (5 bits per color + 1 bit for alpha)  */
        _16_ARGB4444 = 7,   /**< 16-bit ARGB pixel format (4 bits per color)  */
        _8_RGB332 = 8,  /**< 8-bit  RGB pixel format  */
        _8_ARGB2222 = 9,    /**< 8-bit  ARGB pixel format  */
        _32_ABGR8888 = 10,  /**< 32-bit ABGR pixel format  */
        _32_RGBA8888 = 11,  /**< 32-bit RGBA pixel format  */
        _32_BGRA8888 = 12,  /**< 32-bit BGRA pixel format  */
        _32_BGR888 = 13,    /**< 32-bit BGR pixel format  */
        _24_BGR888 = 14,    /**< 24-bit BGR pixel format  */
        _16_BGR565 = 15,    /**< 16-bit BGR pixel format  */
        _16_BGR555 = 16,    /**< 16-bit BGR pixel format (5 bits per color)  */
        _16_ABGR1555 = 17,  /**< 16-bit ABGR pixel format (5 bits per color + 1 bit for alpha)  */
        _16_ABGR4444 = 18,  /**< 16-bit ABGR pixel format (4 bits per color)  */
        _DXT1 = 19, /**< S3/DirectX Texture Compression 1  */
        _DXT2 = 20, /**< S3/DirectX Texture Compression 2  */
        _DXT3 = 21, /**< S3/DirectX Texture Compression 3  */
        _DXT4 = 22, /**< S3/DirectX Texture Compression 4  */
        _DXT5 = 23, /**< S3/DirectX Texture Compression 5  */
        _16_V8U8 = 24,  /**< 16-bit Bump Map format format (8 bits per color)  */
        _32_V16U16 = 25,    /**< 32-bit Bump Map format format (16 bits per color)  */
        _16_L6V5U5 = 26,    /**< 16-bit Bump Map format format with luminance  */
        _32_X8L8V8U8 = 27,  /**< 32-bit Bump Map format format with luminance  */
        _8_ABGR8888_CLUT = 28,  /**< 8 bits indexed CLUT (ABGR)  */
        _8_ARGB8888_CLUT = 29,  /**< 8 bits indexed CLUT (ARGB)  */
        _4_ABGR8888_CLUT = 30,  /**< 4 bits indexed CLUT (ABGR)  */
        _4_ARGB8888_CLUT = 31,  /**< 4 bits indexed CLUT (ARGB)  */
    }

    public enum VXTEXTURE_BLENDMODE : uint {
        VXTEXTUREBLEND_DECAL = 1,   /**< Texture replace any material information  */
        VXTEXTUREBLEND_MODULATE = 2,    /**< Texture and material are combine. Alpha information of the texture replace material alpha component.  */
        VXTEXTUREBLEND_DECALALPHA = 3,  /**< Alpha information in the texture specify how material and texture are combined. Alpha information of the texture replace material alpha component.  */
        VXTEXTUREBLEND_MODULATEALPHA = 4,   /**< Alpha information in the texture specify how material and texture are combined  */
        VXTEXTUREBLEND_DECALMASK = 5,
        VXTEXTUREBLEND_MODULATEMASK = 6,
        VXTEXTUREBLEND_COPY = 7,    /**< Equivalent to DECAL  */
        VXTEXTUREBLEND_ADD = 8,
        VXTEXTUREBLEND_DOTPRODUCT3 = 9, /**< Perform a Dot Product 3 between texture (normal map) and a referential vector given in VXRENDERSTATE_TEXTUREFACTOR.  */
        VXTEXTUREBLEND_MAX = 10,
    }

    public enum VXTEXTURE_FILTERMODE : uint {
        VXTEXTUREFILTER_NEAREST = 1,    /**< No Filter  */
        VXTEXTUREFILTER_LINEAR = 2, /**< Bilinear Interpolation  */
        VXTEXTUREFILTER_MIPNEAREST = 3, /**< Mip mapping  */
        VXTEXTUREFILTER_MIPLINEAR = 4,  /**< Mip Mapping with Bilinear interpolation  */
        VXTEXTUREFILTER_LINEARMIPNEAREST = 5,   /**< Mip Mapping with Bilinear interpolation between mipmap levels.  */
        VXTEXTUREFILTER_LINEARMIPLINEAR = 6,    /**< Trilinear Filtering  */
        VXTEXTUREFILTER_ANISOTROPIC = 7,    /**< Anisotropic filtering  */
    }

    public enum VXTEXTURE_ADDRESSMODE : uint {
        VXTEXTURE_ADDRESSWRAP = 1,  /**< Default mesh wrap mode is used (see CKMesh::SetWrapMode)  */
        VXTEXTURE_ADDRESSMIRROR = 2,    /**< Texture coordinates outside the range [0..1] are flipped evenly.  */
        VXTEXTURE_ADDRESSCLAMP = 3, /**< Texture coordinates greater than 1.0 are set to 1.0, and values less than 0.0 are set to 0.0.  */
        VXTEXTURE_ADDRESSBORDER = 4,    /**< When texture coordinates are greater than 1.0 or less than 0.0  texture is set to a color defined in CKMaterial::SetTextureBorderColor.  */
        VXTEXTURE_ADDRESSMIRRORONCE = 5,    /**<   */
    }

    public enum VXBLEND_MODE : uint {
        VXBLEND_ZERO = 1,   /**< Blend factor is (0, 0, 0, 0).  */
        VXBLEND_ONE = 2,    /**< Blend factor is (1, 1, 1, 1).  */
        VXBLEND_SRCCOLOR = 3,   /**< Blend factor is (Rs, Gs, Bs, As).  */
        VXBLEND_INVSRCCOLOR = 4,    /**< Blend factor is (1-Rs, 1-Gs, 1-Bs, 1-As).  */
        VXBLEND_SRCALPHA = 5,   /**< Blend factor is (As, As, As, As).  */
        VXBLEND_INVSRCALPHA = 6,    /**< Blend factor is (1-As, 1-As, 1-As, 1-As).  */
        VXBLEND_DESTALPHA = 7,  /**< Blend factor is (Ad, Ad, Ad, Ad).  */
        VXBLEND_INVDESTALPHA = 8,   /**< Blend factor is (1-Ad, 1-Ad, 1-Ad, 1-Ad).  */
        VXBLEND_DESTCOLOR = 9,  /**< Blend factor is (Rd, Gd, Bd, Ad).  */
        VXBLEND_INVDESTCOLOR = 10,  /**< Blend factor is (1-Rd, 1-Gd, 1-Bd, 1-Ad).  */
        VXBLEND_SRCALPHASAT = 11,   /**< Blend factor is (f, f, f, 1); f = min(As, 1-Ad).  */
        // VXBLEND_BOTHSRCALPHA = 12,  /**< Source blend factor is (As, As, As, As) and destination blend factor is (1-As, 1-As, 1-As, 1-As)  */
        // VXBLEND_BOTHINVSRCALPHA = 13,   /**< Source blend factor is (1-As, 1-As, 1-As, 1-As) and destination blend factor is (As, As, As, As)  */
    }

    public enum VXFILL_MODE : uint {
        VXFILL_POINT = 1,   /**< Vertices rendering  */
        VXFILL_WIREFRAME = 2,   /**< Edges rendering  */
        VXFILL_SOLID = 3,   /**< Face rendering  */
    }

    public enum VXSHADE_MODE : uint {
        VXSHADE_FLAT = 1,   /**< Flat Shading  */
        VXSHADE_GOURAUD = 2,    /**< Gouraud Shading  */
        VXSHADE_PHONG = 3,  /**< Phong Shading (Not yet supported by most implementation)  */
    }

    public enum VXCMPFUNC : uint {
        VXCMP_NEVER = 1,    /**< Always fail the test.  */
        VXCMP_LESS = 2, /**< Accept if value if less than current value.  */
        VXCMP_EQUAL = 3,    /**< Accept if value if equal than current value.  */
        VXCMP_LESSEQUAL = 4,    /**< Accept if value if less or equal than current value.  */
        VXCMP_GREATER = 5,  /**< Accept if value if greater than current value.  */
        VXCMP_NOTEQUAL = 6, /**< Accept if value if different than current value.  */
        VXCMP_GREATEREQUAL = 7, /**< Accept if value if greater or equal current value.  */
        VXCMP_ALWAYS = 8,   /**< Always accept the test.  */
    }

    public enum VXMESH_LITMODE : uint {
        VX_PRELITMESH = 0,  /**< Lighting use color information store with vertices  */
        VX_LITMESH = 1, /**< Lighting is done by renderer using normals and face material information.  */
    }

}
