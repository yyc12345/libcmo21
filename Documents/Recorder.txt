CKFile in VT21: 0xC8, 200, count50; in VT25: 0xE0, 224, count 56
lost 24 byte, 6 fields or 2 lists

m_FileName
in VT21 +34, 136
in VT25 +31, 124

m_MappedFile
in VT21 +37, 148
in VT25 +34, 136

m_Context
in VT21 +35, 140
in VT25 +32, 128

VxMemoryMappedFile and CKFileInfo seems no change
CKFileObject still no change
CKFilePluginDependencies still no change
CKFileManagerData no change (12)

CKStateChunk is 0x28u black box
CKBufferParser also is 0x10u black box

struct CKGUID {
DWORD d1,d2;
};

struct XBaseString {
	// the string 
	char*	m_Buffer;
	// the length of the string
	WORD	m_Length;
	// the allocated size
	WORD	m_Allocated;
};

struct XArray {
	// elements start {secret}
	DWORD*			m_Begin;
	// elements end {secret}
	DWORD*			m_End;
	// reserved end {secret}
	DWORD*			m_AllocatedEnd;
}
struct XClassArray {
	DWORD*			m_Begin;
	DWORD*			m_End;
	DWORD*			m_AllocatedEnd;
}
struct XSArray {
	DWORD*			m_Begin;
	DWORD*			m_End;
};
struct XBitArray {
    DWORD m_Data_Flags;
    DWORD m_Size;
};

// <T, K> = <int, CK_ID>
typedef struct XFileObjectsTable::Entry {
    CK_ID key;
    int data;
    struct Entry* next;
} *XFileObjectsTable::pEntry;
struct XFileObjectsTable {
    struct XFileObjectsTable::XSArray_pEntry_ {
        XFileObjectsTable::pEntry* m_Begin;
        XFileObjectsTable::pEntry* m_End;
    }m_Table;
    struct XFileObjectsTable::XClassArray_pEntry_ {
        XFileObjectsTable::pEntry*			m_Begin;
        XFileObjectsTable::pEntry*			m_End;
        XFileObjectsTable::pEntry*			m_AllocatedEnd;
    }m_Pool;
};


struct CKFileInfo 
{
	DWORD				ProductVersion;		// Virtools Version (Dev/Creation). (CK_VIRTOOLS_VERSION)
	DWORD				ProductBuild;		// Virtools Build Number.
	DWORD				FileWriteMode;		// Options used to save this file. (CK_FILE_WRITEMODE)
	DWORD				FileVersion;		// Version of file format when file was saved.
	DWORD				CKVersion;			// Version of CK when file was saved.
	DWORD				FileSize;			// Size of file in bytes.
	DWORD				ObjectCount;		// Number of objects stored in the file. 	
	DWORD				ManagerCount;		// Number of managers which saved data in the file.
	DWORD				MaxIDSaved;			// Maximum Object identifier saved
	DWORD				Crc;				// Crc of data
	DWORD				Hdr1PackSize;		// Reserved
	DWORD				Hdr1UnPackSize;		// Reserved
	DWORD				DataPackSize;		// Reserved
	DWORD				DataUnPackSize;		// Reserved
};

struct CKFileObject {
	CK_ID			Object;			// ID of the object being load/saved (as it will be/was saved in the file)
	CK_ID			CreatedObject;	// ID of the object being created
	CK_CLASSID		ObjectCid;		// Class Identifier of the object
	CKObject*		ObjPtr;			// A pointer to the object itself (as CreatedObject when loading)
	CKSTRING		Name;			// Name of the Object
	CKStateChunk*	Data;			// A CKStateChunk that contains object information
	int				PostPackSize;	// When compressed chunk by chunk : size of Data after compression
	int				PrePackSize;	// When compressed chunk by chunk : size of Data before compression
	CK_FO_OPTIONS	Options;		// When loading an object it may be renamed , use to replace another object 	
	int				FileIndex;		// Position of the object data inside uncompressed file buffer
	CKDWORD			SaveFlags;		// Flags used when this object was saved.	
};

struct CKFileManagerData {
	CKStateChunk *data;
	CKGUID Manager;
}

struct CKFilePluginDependencies{
	int				m_PluginCategory;
	XArray/*<CKGUID>*/  m_Guids;
	XBitArray		ValidGuids;
};

struct VxMemoryMappedFile {
    void*      m_hFile;
    void*      m_hFileMapping; // Handle of memory mapped file
    void*       m_pMemoryMappedFileBase;
    DWORD       m_cbFile;
    DWORD m_errCode;  
};

struct CKBufferParser {
    char* m_ReaderBegin;
    DWORD m_ReaderPos;
    CKBOOL m_NeedManualFree;
    DWORD m_ReaderSize;
};

struct CKFile {
// 0
	int							m_SaveIDMax;			// Maximum CK_ID found when saving or loading objects  {secret}
	XArray/*<CKFileObject>*/		m_FileObjects;			// List of objects being saved / loaded   {secret}
	XArray/*<CKFileManagerData>*/	m_ManagersData;			// Manager Data loaded  {secret}
	XClassArray/*<CKFilePluginDependencies>*/ m_PluginsDep;	// Plugins dependencies for this file  {secret}
	XClassArray/*<XIntArray>*/		m_IndexByClassId;		// List of index in the m_FileObjects table sorted by ClassID  {secret}
	XClassArray/*<XString>*/		m_IncludedFiles;		// List of files that should be inserted in the CMO file.  {secret}
// 16
    CKFileInfo					m_FileInfo;				// Headers summary  {secret}
// 16 + 14 = 30
    // guess
    DWORD unknow_fields;
	XBitArray					m_AlreadySavedMask;			// BitArray of IDs already saved  {secret}
// 30 + 3 = 33
	CKDWORD						m_Flags;				// Flags used to save file {secret}
	CKSTRING					m_FileName;				// Current file name  {secret}
	CKContext*					m_Context;				// CKContext on which file is loaded/Saved  {secret}
	CKBufferParser*				m_Parser;
	VxMemoryMappedFile*			m_MappedFile;
// 33 + 5 = 38
    // guess
    XFileObjectsTable			m_ObjectsHashTable;
// 38 + 5 = 43
    //[guess]
	CKBOOL					m_SceneSaved;
	CKBOOL				m_ReadFileDataDone;
// 43 + 2 = 45
	XBitArray					m_AlreadyReferencedMask;	// BitArray of IDs already referenced  {secret}
	XObjectPointerArray			m_ReferencedObjects;
// 45 + 2 + 3 = 50
};
    
	VxTimeProfiler				m_Chrono;
    
	XFileObjectsTable			m_ObjectsHashTable;
//#ifdef USECHUNKTABLE
	XClassArray/*<CKFileChunk>*/	m_FileChunks;			// Instead of allocating chunk per chunk a whole memory buffer is allocated to store all chunks and their readers
	CKFileChunk*				m_ObjectChunks;
	CKFileChunk*				m_ManagersChunks;
	VxMemoryPool				m_ChunkBuffers;			// Store all decompressed file buffer in memory so that all chunks directly points to it...
														// can only work for recent files ( > 2.0)
	BYTE*						m_CurrentChunkBufferPtr;
//#endif					

	CKBOOL						m_ReadFileDataDone;
	CKBOOL						m_SceneSaved;
//-----------
	XIntArray					m_DuplicateNameFounds;	// A List of file object index for which a existing object with the same name has been
														// found, this list is build if the load option contains CK_LOAD_AUTOMATICMODE or CK_LOAD_DODIALOG

//----- 	
	XBitArray					m_AlreadySavedMask;			// BitArray of IDs already saved  {secret}
	XBitArray					m_AlreadyReferencedMask;	// BitArray of IDs already referenced  {secret}
	XObjectPointerArray			m_ReferencedObjects;
};
